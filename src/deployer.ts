/**
 * Deploy MCP servers to Vercel
 */

import { execa } from "execa";
import { writeFile, mkdir, readFile, access, rm } from "node:fs/promises";
import { join, dirname } from "node:path";
import { randomBytes } from "node:crypto";
import type {
  McpServerInfo,
  DeploymentResult,
  DeployOptions,
  McpClientConfig,
} from "./types.js";

async function fileExists(path: string): Promise<boolean> {
  try {
    await access(path);
    return true;
  } catch {
    return false;
  }
}

/**
 * Check if Vercel CLI is installed and authenticated
 */
export async function checkVercelCli(): Promise<{
  installed: boolean;
  authenticated: boolean;
  error?: string;
}> {
  try {
    await execa("vercel", ["--version"]);
  } catch {
    return {
      installed: false,
      authenticated: false,
      error: "Vercel CLI not found. Install with: npm i -g vercel",
    };
  }

  try {
    // Check if authenticated by trying to list projects
    await execa("vercel", ["whoami"], { timeout: 10000 });
    return { installed: true, authenticated: true };
  } catch {
    return {
      installed: true,
      authenticated: false,
      error: "Not logged in to Vercel. Run: vercel login",
    };
  }
}

/**
 * Generate a secure random token
 */
function generateToken(): string {
  return randomBytes(32).toString("hex");
}

/**
 * Create Vercel serverless function wrapper for Node MCP server
 */
async function createNodeWrapper(
  serverInfo: McpServerInfo,
  _options: DeployOptions
): Promise<string> {
  const apiDir = join(serverInfo.path, "api");
  await mkdir(apiDir, { recursive: true });

  // Create the wrapper that exposes the MCP server over HTTP/SSE
  const wrapperCode = `
// Auto-generated by hosty - Vercel serverless wrapper for MCP
import { createServer } from "@modelcontextprotocol/sdk/server/index.js";
import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";

// Import the user's MCP server setup
// This expects the project to export a 'server' or 'createMcpServer' function
let serverModule;
try {
  serverModule = await import("../${serverInfo.entryPoint.replace(/\.ts$/, ".js")}");
} catch (e) {
  console.error("Failed to import MCP server:", e);
}

export default async function handler(req, res) {
  // Handle CORS
  res.setHeader("Access-Control-Allow-Origin", "*");
  res.setHeader("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
  res.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");

  if (req.method === "OPTIONS") {
    res.status(200).end();
    return;
  }

  // Basic auth check if AUTH_TOKEN is set
  const authToken = process.env.AUTH_TOKEN;
  if (authToken) {
    const auth = req.headers.authorization;
    if (!auth || auth !== \`Bearer \${authToken}\`) {
      res.status(401).json({ error: "Unauthorized" });
      return;
    }
  }

  // Health check
  if (req.method === "GET" && !req.headers.accept?.includes("text/event-stream")) {
    res.status(200).json({ status: "ok", type: "mcp-server" });
    return;
  }

  // SSE endpoint for MCP
  if (req.headers.accept?.includes("text/event-stream")) {
    res.setHeader("Content-Type", "text/event-stream");
    res.setHeader("Cache-Control", "no-cache");
    res.setHeader("Connection", "keep-alive");

    const transport = new SSEServerTransport("/api/mcp", res);

    if (serverModule?.server) {
      await serverModule.server.connect(transport);
    } else if (serverModule?.createMcpServer) {
      const server = await serverModule.createMcpServer();
      await server.connect(transport);
    } else {
      res.status(500).json({ error: "No MCP server export found" });
    }
    return;
  }

  // POST for MCP messages
  if (req.method === "POST") {
    // Handle incoming MCP message
    res.status(200).json({ received: true });
    return;
  }

  res.status(405).json({ error: "Method not allowed" });
}
`.trim();

  const wrapperPath = join(apiDir, "mcp.js");
  await writeFile(wrapperPath, wrapperCode);

  return wrapperPath;
}

/**
 * Create vercel.json if it doesn't exist
 */
async function ensureVercelConfig(
  serverInfo: McpServerInfo,
  options: DeployOptions
): Promise<void> {
  const configPath = join(serverInfo.path, "vercel.json");

  // Check if vercel.json exists
  if (await fileExists(configPath)) {
    return;
  }

  const config: Record<string, unknown> = {
    version: 2,
    functions: {
      "api/mcp.js": {
        maxDuration: 60,
      },
    },
  };

  // Add env vars if provided
  if (options.authToken) {
    config.env = {
      AUTH_TOKEN: options.authToken,
    };
  }

  await writeFile(configPath, JSON.stringify(config, null, 2));
}

/**
 * Deploy to Vercel
 */
export async function deploy(
  serverInfo: McpServerInfo,
  options: DeployOptions = {}
): Promise<DeploymentResult> {
  // Generate auth token if not provided
  const authToken = options.authToken || generateToken();

  // Create wrapper based on server type
  let wrapperPath: string;
  if (serverInfo.type === "node") {
    wrapperPath = await createNodeWrapper(serverInfo, options);
  } else {
    // Python support would go here
    return {
      success: false,
      error: "Python MCP servers not yet supported for Vercel deployment",
    };
  }

  // Ensure vercel.json exists
  await ensureVercelConfig(serverInfo, { ...options, authToken });

  // Build the project first if it's TypeScript
  const hasTsConfig = await fileExists(join(serverInfo.path, "tsconfig.json"));
  if (hasTsConfig) {
    try {
      await execa("npm", ["run", "build"], {
        cwd: serverInfo.path,
        stdio: "pipe",
      });
    } catch (e) {
      // Build might not be needed or might fail - continue anyway
    }
  }

  // Deploy to Vercel
  const args = ["deploy", "--yes"];

  if (options.production) {
    args.push("--prod");
  }

  if (options.team) {
    args.push("--scope", options.team);
  }

  if (options.projectName) {
    args.push("--name", options.projectName);
  }

  // Set environment variables
  if (authToken) {
    args.push("--env", `AUTH_TOKEN=${authToken}`);
  }

  if (options.env) {
    for (const [key, value] of Object.entries(options.env)) {
      args.push("--env", `${key}=${value}`);
    }
  }

  try {
    const result = await execa("vercel", args, {
      cwd: serverInfo.path,
      stdio: "pipe",
    });

    // Extract URL from output
    const url = result.stdout.trim().split("\n").pop() || "";

    if (!url.startsWith("http")) {
      return {
        success: false,
        error: `Unexpected Vercel output: ${result.stdout}`,
      };
    }

    const mcpConfig: McpClientConfig = {
      name: serverInfo.name,
      transport: {
        type: "sse",
        url: `${url}/api/mcp`,
      },
    };

    if (authToken) {
      mcpConfig.auth = {
        type: "bearer",
        token: authToken,
      };
    }

    return {
      success: true,
      url,
      projectName: options.projectName || serverInfo.name,
      mcpConfig,
    };
  } catch (e) {
    const error = e as Error & { stderr?: string };
    return {
      success: false,
      error: error.stderr || error.message,
    };
  } finally {
    // Clean up generated wrapper
    try {
      await rm(dirname(wrapperPath), { recursive: true, force: true });
    } catch {
      // Ignore cleanup errors
    }
  }
}

/**
 * Format deployment result for display
 */
export function formatDeploymentResult(result: DeploymentResult): string {
  if (!result.success) {
    return `Deployment failed: ${result.error}`;
  }

  const lines = [
    `Deployed to ${result.url}`,
    "",
    "MCP endpoint: " + result.mcpConfig?.transport.url,
    "",
  ];

  if (result.mcpConfig?.auth) {
    lines.push(`Auth token: ${result.mcpConfig.auth.token}`);
    lines.push("");
  }

  return lines.join("\n");
}
